# -*- coding: utf-8 -*-
"""Assesment Completion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aTT09rYSZ8tDCV5lHZyaDOdgsxTpide3
"""

# Define an empty dictionary to represent option_chain_data
option_chain_data = {}

# Now you can assign the JSON data to the 'json' key
option_chain_data['json'] = {
    "data": [
        {
            "strike_price": 19500,
            "side": "CE",
            "bid_price": 0.65,
            "ask_price": 2302.25
        },
        {
            "strike_price": 19500,
            "side": "PE",
            "bid_price": 0.75,
            "ask_price": 0.85
        },
        # ... add more data here
    ]
}

# Now you can access option_chain_data['json'] to get the data
print(option_chain_data['json'])

import pandas as pd

# Simulated data to mimic the option chain data
# You can adjust this data to test different scenarios
sample_data = {
    'instrument_name': ['NIFTY', 'NIFTY', 'BANKNIFTY', 'BANKNIFTY'],
    'strike_price': [19500, 19600, 39500, 39600],
    'side': ['PE', 'CE', 'PE', 'CE'],
    'bid_price': [0.65, None, 1.2, None],
    'ask_price': [None, 2302.25, None, 3200.75]
}
options_df = pd.DataFrame(sample_data)

# Function to simulate getting option chain data
def get_option_chain_data(instrument_name: str, expiry_date: str, side: str) -> pd.DataFrame:
    # Filter based on instrument and side
    filtered_df = options_df[(options_df['instrument_name'] == instrument_name) & (options_df['side'] == side)]

    # Select the highest bid for PE or the highest ask for CE
    if side == 'PE':
        filtered_df = filtered_df[['instrument_name', 'strike_price', 'side', 'bid_price']]
        filtered_df = filtered_df.rename(columns={'bid_price': 'bid/ask'}).dropna(subset=['bid/ask'])
    elif side == 'CE':
        filtered_df = filtered_df[['instrument_name', 'strike_price', 'side', 'ask_price']]
        filtered_df = filtered_df.rename(columns={'ask_price': 'bid/ask'}).dropna(subset=['bid/ask'])

    return filtered_df

# Function to calculate margin and premium earned
def calculate_margin_and_premium(data: pd.DataFrame) -> pd.DataFrame:
    # Simulated margin requirement value (you can customize this as needed)
    simulated_margin = 2000

    # Assume a fixed lot size for premium calculation
    lot_size = 1200  # You may adjust this to match realistic values

    data['margin_required'] = simulated_margin
    data['premium_earned'] = data['bid/ask'] * lot_size
    return data

# Example usage
expiry_date = '2024-11-10'  # Dummy expiry date, not used in this simulation
instrument_name = 'NIFTY'
side = 'PE'

# Get simulated option chain data
option_chain_data = get_option_chain_data(instrument_name, expiry_date, side)
print("Option Chain Data:")
print(option_chain_data)

# Calculate margin and premium
result_data = calculate_margin_and_premium(option_chain_data)
print("\nOption Chain Data with Calculated Margin and Premium:")
print(result_data)

import pandas as pd

# Sample data (you can modify this for testing purposes)
sample_data = {
    'instrument_name': ['NIFTY', 'NIFTY', 'BANKNIFTY', 'BANKNIFTY'],
    'strike_price': [19500, 19600, 39500, 39600],
    'side': ['PE', 'CE', 'PE', 'CE'],
    'bid_price': [0.65, None, 1.2, None],
    'ask_price': [None, 2302.25, None, 3200.75]
}
options_df = pd.DataFrame(sample_data)

def get_option_chain_data(instrument_name: str, side: str) -> pd.DataFrame:
    filtered_df = options_df[(options_df['instrument_name'] == instrument_name) & (options_df['side'] == side)]
    if side == 'PE':
        filtered_df = filtered_df[['instrument_name', 'strike_price', 'side', 'bid_price']]
        filtered_df = filtered_df.rename(columns={'bid_price': 'bid/ask'}).dropna(subset=['bid/ask'])
    elif side == 'CE':
        filtered_df = filtered_df[['instrument_name', 'strike_price', 'side', 'ask_price']]
        filtered_df = filtered_df.rename(columns={'ask_price': 'bid/ask'}).dropna(subset=['bid/ask'])
    return filtered_df

def calculate_margin_and_premium(data: pd.DataFrame) -> pd.DataFrame:
    simulated_margin = 2000
    lot_size = 1200
    data['margin_required'] = simulated_margin
    data['premium_earned'] = data['bid/ask'] * lot_size
    return data

# CLI Interaction
def main():
    print("Welcome to the Option Chain Assessment Interactive CLI")
    instrument_name = input("Enter Instrument Name (e.g., NIFTY or BANKNIFTY): ")
    side = input("Enter Option Type (PE for Put, CE for Call): ")

    option_chain_data = get_option_chain_data(instrument_name, side)
    print("\nOption Chain Data:")
    print(option_chain_data)

    if not option_chain_data.empty:
        result_data = calculate_margin_and_premium(option_chain_data)
        print("\nOption Chain Data with Calculated Margin and Premium:")
        print(result_data)
    else:
        print("\nNo data found for the specified inputs. Try different parameters.")

if __name__ == "__main__":
    main()

!pip install streamlit

import pandas as pd
import streamlit as st

# Sample data
sample_data = {
    'instrument_name': ['NIFTY', 'NIFTY', 'BANKNIFTY', 'BANKNIFTY'],
    'strike_price': [19500, 19600, 39500, 39600],
    'side': ['PE', 'CE', 'PE', 'CE'],
    'bid_price': [0.65, None, 1.2, None],
    'ask_price': [None, 2302.25, None, 3200.75]
}
options_df = pd.DataFrame(sample_data)

def get_option_chain_data(instrument_name: str, side: str) -> pd.DataFrame:
    filtered_df = options_df[(options_df['instrument_name'] == instrument_name) & (options_df['side'] == side)]
    if side == 'PE':
        filtered_df = filtered_df[['instrument_name', 'strike_price', 'side', 'bid_price']]
        filtered_df = filtered_df.rename(columns={'bid_price': 'bid/ask'}).dropna(subset=['bid/ask'])
    elif side == 'CE':
        filtered_df = filtered_df[['instrument_name', 'strike_price', 'side', 'ask_price']]
        filtered_df = filtered_df.rename(columns={'ask_price': 'bid/ask'}).dropna(subset=['bid/ask'])
    return filtered_df

def calculate_margin_and_premium(data: pd.DataFrame) -> pd.DataFrame:
    simulated_margin = 2000
    lot_size = 1200
    data['margin_required'] = simulated_margin
    data['premium_earned'] = data['bid/ask'] * lot_size
    return data

# Streamlit App
st.title("Option Chain Assessment Interactive App")
instrument_name = st.selectbox("Select Instrument Name", options=['NIFTY', 'BANKNIFTY'])
side = st.radio("Select Option Type", options=['PE', 'CE'])

if st.button("Get Option Chain Data"):
    option_chain_data = get_option_chain_data(instrument_name, side)
    st.write("Option Chain Data:")
    st.write(option_chain_data)

    if not option_chain_data.empty:
        result_data = calculate_margin_and_premium(option_chain_data)
        st.write("Option Chain Data with Calculated Margin and Premium:")
        st.write(result_data)
    else:
        st.warning("No data found for the specified inputs.")

!pip install streamlit ngrok

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import pandas as pd
# import streamlit as st
# 
# sample_data = {
#     'instrument_name': [
#         'NIFTY', 'NIFTY', 'BANKNIFTY', 'BANKNIFTY',
#         'NIFTY', 'BANKNIFTY', 'NIFTY', 'BANKNIFTY',
#         'NIFTY', 'NIFTY', 'BANKNIFTY', 'BANKNIFTY',
#         'NIFTY', 'BANKNIFTY', 'NIFTY', 'BANKNIFTY',
#         'NIFTY', 'BANKNIFTY', 'NIFTY', 'BANKNIFTY'
#     ],
#     'strike_price': [
#         19500, 19600, 39500, 39600,
#         19700, 39700, 19800, 39800,
#         19900, 20000, 39900, 40000,
#         20100, 40100, 20200, 40200,
#         20300, 40300, 20400, 40400
#     ],
#     'side': [
#         'PE', 'CE', 'PE', 'CE',
#         'CE', 'PE', 'PE', 'CE',
#         'CE', 'PE', 'CE', 'PE',
#         'PE', 'CE', 'PE', 'CE',
#         'CE', 'PE', 'CE', 'PE'
#     ],
#     'bid_price': [
#         0.65, None, 1.2, None,
#         2.5, 1.0, 0.75, None,
#         1.5, 3.0, None, 4.0,
#         1.8, 2.2, None, 3.5,
#         0.9, None, 2.8, 3.6
#     ],
#     'ask_price': [
#         None, 2302.25, None, 3200.75,
#         2310.00, None, 2320.50, 3210.00,
#         None, 3340.00, 2400.00, None,
#         2350.00, None, 2430.00, 3300.00,
#         None, 3400.00, 2500.00, None
#     ]
# }
# 
# 
# options_df = pd.DataFrame(sample_data)
# 
# def get_option_chain_data(instrument_name: str, side: str) -> pd.DataFrame:
#     filtered_df = options_df[(options_df['instrument_name'] == instrument_name) & (options_df['side'] == side)]
#     if side == 'PE':
#         filtered_df = filtered_df[['instrument_name', 'strike_price', 'side', 'bid_price']]
#         filtered_df = filtered_df.rename(columns={'bid_price': 'bid/ask'}).dropna(subset=['bid/ask'])
#     elif side == 'CE':
#         filtered_df = filtered_df[['instrument_name', 'strike_price', 'side', 'ask_price']]
#         filtered_df = filtered_df.rename(columns={'ask_price': 'bid/ask'}).dropna(subset=['bid/ask'])
#     return filtered_df
# 
# def calculate_margin_and_premium(data: pd.DataFrame) -> pd.DataFrame:
#     simulated_margin = 2000
#     lot_size = 1200
#     data['margin_required'] = simulated_margin
#     data['premium_earned'] = data['bid/ask'] * lot_size
#     return data
# 
# # Streamlit App
# st.title("Option Chain Assessment Interactive App")
# instrument_name = st.selectbox("Select Instrument Name", options=['NIFTY', 'BANKNIFTY'])
# side = st.radio("Select Option Type", options=['PE', 'CE'])
# 
# if st.button("Get Option Chain Data"):
#     option_chain_data = get_option_chain_data(instrument_name, side)
#     st.write("Option Chain Data:")
#     st.write(option_chain_data)
# 
#     if not option_chain_data.empty:
#         result_data = calculate_margin_and_premium(option_chain_data)
#         st.write("Option Chain Data with Calculated Margin and Premium:")
#         st.write(result_data)
#     else:
#         st.warning("No data found for the specified inputs.")
#

!ngrok config add-authtoken ''

from pyngrok import ngrok

# Start ngrok tunnel on port 8501 with HTTP configuration
public_url = ngrok.connect(8501, "http")
print(f'Streamlit App URL: {public_url}')

# Start Streamlit in the background
!streamlit run app.py &>/dev/null &

























